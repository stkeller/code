//Data Sets //

// Men Life Expectancy per Country
[7.6,12.2,8.1,4.9,6.3,8.0,6.2,5.0,4.9,4.0,4.5,13.6,5.6,4.2,9.8,7.1,0.9,3.1,1.8,2.6,26.0,15.3,6.1,3.7,12.3,0.7,0.3,3.1,7.8,23.3,3.8,1.1,6.1,
3.9,3.0,9.1,21.3,11.7,6.0,13.7,2.4,7.8,5.8,7.7,54.6,12.0,9.3,4.9,8.4,27.4,13.1,11.7,2.6,6.4,8.3,8.8,19.1,16.7,6.2,3.5,7.7,14.9,10.0,9.6,
19.1,12.8,2.9,4.6,17.2,6.2,4.3,11.0,7.8,3.3,9.1,16.2,17.4,2.8,5.6,7.6,9.6,4.8,11.0,4.6,56.4,2.0,7.3,1.3,17.6,8.6,23.0,3.4,17.8,3.8,1.7,
5.4,3.3,7.9,7.2,6.1,27.6,19.0,23.9,5.2,5.3,2.5,3.0,19.5,8.4,3.4,4.7,32.5,3.1,4.5,8.0,6.3,7.4,1.7,3.7,7.3,3.4,23.1,4.0,3.7,4.2,4.3,4.4,
5.8,9.0,12.4,18.2,0.2,3.6,7.7,27.6,7.9,7.0,0.9,20.2,4.3,10.0,18.3,4.4,1.2,11.0,3.5,7.9,18.3,14.4,6.1,4.5,2.6,13.5,8.2,31.0,22.3,21.2,3.5,
7.0,20.0,7.6,3.7,5.7,31.8,0.7,3.5,9.2,4.9,3.1,8.8,2.0,8.4,2.8,9.4,4.5,4.1,7.7,1.7,4.2] @=> float menLife[];

// Women Life Expectancy per Country
[9.5,15.9,19.1,6.0,9.5,8.8,8.5,6.5,5.3,4.3,6.4,13.7,20.0,7.4,12.5,7.2,0.4,2.3,4.5,4.4,29.9,19.9,11.0,6.7,10.0,0.3,0.1,4.5,7.0,22.6,4.1,0.3,
8.7,2.8,2.1,15.0,16.9,14.8,10.3,13.2,2.7,7.7,7.9,7.5,68.6,9.5,16.4,22.6,5.1,18.5,11.8,22.6,3.9,12.9,7.1,9.7,16.1,13.1,5.6,3.6,4.0,21.4,6.7,
10.9,25.8,9.8,6.6,1.7,25.7,8.3,5.6,10.9,6.2,4.3,16.8,22.5,10.6,2.0,5.6,9.6,17.2,4.1,21.2,6.2,40.7,1.8,9.4,1.4,13.1,10.1,28.0,4.1,13.0,6.3,
3.5,10.0,3.6,23.8,10.9,7.0,37.3,22.5,44.0,12.3,5.2,5.2,3.6,20.0,10.2,1.3,8.8,43.0,2.4,4.4,12.5,6.8,8.8,0.9,4.4,5.8,3.1,26.8,8.7,4.9,4.9,
1.3,7.4,10.1,10.4,13.1,12.8,3.3,3.1,5.6,31.8,6.8,6.2,0.4,15.1,5.9,18.5,21.4,6.2,4.5,24.5,15.9,13.6,20.4,16.4,4.9,2.3,3.2,13.5,8.2,33.7,
27.7,22.2,7.7,13.7,26.0,7.5,4.5,22.5,30.8,0.6,6.2,11.3,8.6,5.1,6.8,12.0,7.1,5.8,8.5,7.7,5.2,9.3,2.4,4.1] @=> float womenLife[];

// Population Growth Rate per Country
[2005.0,2009,2010,2000,2002,2001,2011,2007,2011,2011,2011,2011,2004,2009,2011,2011,2002,2000,2011,2009,2011,2006,2009,1991,2011,1990,2011,
2010,2011,1990,2008,1993,2011,2011,2011,2010,1991,2001,2011,2011,2010,2011,2011,2011,2002,2001,2010,2010,2010,1983,2011,2006,2005,2007,
2011,2011,1993,2011,2011,2006,1991,2011,2006,2001,2011,2002,2011,1994,2011,1999,2010,2011,2011,2010,2008,2006,2011,2006,2011,2011,2011,
2011,2011,2011,2009,2005,2008,2005,2011,2007,2008,2010,2011,2011,2005,2004,2010,2006,2004,2011,1999,2011,2008,2011,2011,2000,2005,2011,
2011,1997,1990,2008,2008,2011,2008,2011,2010,2001,1986,2005,2011,2010,2008,2005,2011,2000,2011,2011,2011,2011,2011,2011,2011,2011,2011,
2011,2011,1996,1998,2001,2007,1991,2001,2007,2006,2009,2006,2010,2003,2005,2004,2011,2011,2011,1999,2011,2011,2010,2004,1997,2011,2011,
2010,2011,2011,2008,2011,2005,2009,2011,2008,2011,2006,2011,2011,2009,2011,2011,2004] @=> float growthRate[];

//                       //
// Data Helper Functions //
//                       //

// Find Minimun Value
fun float minVal( float dataArray[] )
{
    dataArray[0] => float minimum;
    for( 1 => int i; i < dataArray.cap(); i++ )
    {
        if( minimum > dataArray[i] )
        {
            dataArray[i] => minimum;
        }
    }
    return minimum;
}

// Find Maximun Value
fun float maxVal( float dataArray[] )
{
    dataArray[0] => float minimum;
    for( 1 => int i; i < dataArray.cap(); i++ )
    {
        if( minimum < dataArray[i] )
        {
            dataArray[i] => minimum;
        }
    }
    return minimum;
}
// Data Normalization
fun float arrayNormalization( string dataName,float dataArray[], float oldMin,
                              float newMin, float oldMax, float newMax)
{
    for( 0 => int i; i < dataArray.cap(); i++ )
    {
        // Normalization Equation (newvalue = (max'-min')/(max-min)*(value-max)+max')
        <<< dataName, "Old Value = ", dataArray[i] >>>;
        (newMax - newMin) / (oldMax - oldMin) * (dataArray[i] - oldMax) + newMax
         => dataArray[i];
        <<< "New Value = ", dataArray[i] >>>;
    }
}

//                   //
// Data Manipulation //
//                   //

// Find mininum and maximun values

// Men unemployment min and max
minVal(menLife) => float menMin;
maxVal(menLife) => float menMax;
// Women unemployment min and max
minVal(womenLife) => float womenMin;
maxVal(womenLife) => float womenMax;
// Year  min and max
minVal(growthRate) => float growthMin;
maxVal(growthRate) => float growthMax;
// Print results
<<< "Men minimum =", menMin >>>;
<<< "Men maximum =", menMax >>>;
<<< "Women minimum =", womenMin >>>;
<<< "Women maximum =", womenMax >>>;
<<< "Growth minimum =", growthMin >>>;
<<< "Growth maximum =", growthMax >>>;

// Normalize Data
0 => float newMinVal;
100 => float newMaxVal;
arrayNormalization("Men Life Expectancy", menLife, menMin, newMinVal, menMax, newMaxVal);
arrayNormalization("Women Life Expectancy", womenLife, womenMin, newMinVal, womenMax, newMaxVal);
arrayNormalization("Population Growth", growthRate, growthMin, 0, growthMax, 4);



// Audio //

// import sound files
// Kick
me.sourceDir() + "/Audio/kick1.wav" => string kickFile1;
if( me.args() ) me.arg(0) => kickFile1;
    
me.sourceDir() + "/Audio/kick2.wav" => string kickFile2;
if( me.args() ) me.arg(0) => kickFile2;
    
me.sourceDir() + "/Audio/kick3.wav" => string kickFile3;
if( me.args() ) me.arg(0) => kickFile3;
    
me.sourceDir() + "/Audio/kick4.wav" => string kickFile4;
if( me.args() ) me.arg(0) => kickFile4;

// Snare Drums A
me.sourceDir() + "/Audio/snareA1.wav" => string snareFileA1;
if( me.args() ) me.arg(0) => snareFileA1;
    
me.sourceDir() + "/Audio/snareA2.wav" => string snareFileA2;
if( me.args() ) me.arg(0) => snareFileA2;
    
me.sourceDir() + "/Audio/snareA3.wav" => string snareFileA3;
if( me.args() ) me.arg(0) => snareFileA3;

me.sourceDir() + "/Audio/snareA4.wav" => string snareFileA4;
if( me.args() ) me.arg(0) => snareFileA4;
    
// Snare Drums B
me.sourceDir() + "/Audio/snareB1.wav" => string snareFileB1;
if( me.args() ) me.arg(0) => snareFileB1;
    
me.sourceDir() + "/Audio/snareB2.wav" => string snareFileB2;
if( me.args() ) me.arg(0) => snareFileB2;
    
me.sourceDir() + "/Audio/snareB3.wav" => string snareFileB3;
if( me.args() ) me.arg(0) => snareFileB3;

me.sourceDir() + "/Audio/snareB4.wav" => string snareFileB4;
if( me.args() ) me.arg(0) => snareFileB4;
    
// HiHats
me.sourceDir() + "/Audio/hh1.wav" => string hhFile1;
if( me.args() ) me.arg(0) => hhFile1;
    
me.sourceDir() + "/Audio/hh2.wav" => string hhFile2;
if( me.args() ) me.arg(0) => hhFile2;
    
me.sourceDir() + "/Audio/hh3.wav" => string hhFile3;
if( me.args() ) me.arg(0) => hhFile3;

me.sourceDir() + "/Audio/hh4.wav" => string hhFile4;
if( me.args() ) me.arg(0) => hhFile4;

// Mixer
Gain drumGain => dac;
SndBuf kick1 => drumGain;
kick1.samples() => kick1.pos;
SndBuf kick2 => drumGain;
kick2.samples() => kick2.pos;
SndBuf kick3 => drumGain;
kick3.samples() => kick3.pos;
SndBuf kick4 => drumGain;
kick4.samples() => kick4.pos;
SndBuf snareA1 => drumGain;
snareA1.samples() => snareA1.pos;
SndBuf snareA2 => drumGain;
snareA2.samples() => snareA2.pos;
SndBuf snareA3 => drumGain;
snareA3.samples() => snareA3.pos;
SndBuf snareA4 => drumGain;
snareA4.samples() => snareA4.pos;
SndBuf snareB1 => drumGain;
snareB1.samples() => snareB1.pos;
SndBuf snareB2 => drumGain;
snareB2.samples() => snareB2.pos;
SndBuf snareB3 => drumGain;
snareB3.samples() => snareB3.pos;
SndBuf snareB4 => drumGain;
snareB4.samples() => snareB4.pos;
SndBuf hh1 => drumGain;
hh1.samples() => hh1.pos;
SndBuf hh2 => drumGain;
hh2.samples() => hh2.pos;
SndBuf hh3 => drumGain;
hh3.samples() => hh3.pos;
SndBuf hh4 => drumGain;
hh4.samples() => hh4.pos;

.8  => float kickGain;
.5  => float snareGainA;
.45  => float snareGainB;
.6 => float hhGain;

.9 => drumGain.gain;
kickGain => kick1.gain;
kickGain => kick2.gain;
kickGain => kick3.gain;
kickGain => kick4.gain;
snareGainA => snareA1.gain;
snareGainA => snareA2.gain;
snareGainA => snareA3.gain;
snareGainA => snareA4.gain;
snareGainB => snareB1.gain;
snareGainB => snareB2.gain;
snareGainB => snareB3.gain;
snareGainB => snareB4.gain;
hhGain => hh1.gain;
hhGain => hh2.gain;
hhGain => hh3.gain;
hhGain => hh4.gain;

// load drum files
kickFile1 => kick1.read;
kickFile2 => kick2.read;
kickFile3 => kick3.read;
kickFile4 => kick4.read;
snareFileA1 => snareA1.read;
snareFileA2 => snareA2.read;
snareFileA3 => snareA3.read;
snareFileA4 => snareA4.read;
snareFileB1 => snareB1.read;
snareFileB2 => snareB2.read;
snareFileB3 => snareB3.read;
snareFileB4 => snareB4.read;
hhFile1 => hh1.read;
hhFile2 => hh2.read;
hhFile3 => hh3.read;
hhFile4 => hh4.read;


// Synth 1 Parameters
SawOsc sinePad => ADSR sineEnv => NRev sineReverb => Pan2 sinePan1 => dac;
( 150::ms, 10::ms, 1, 500::ms ) => sineEnv.set;
.15 => sineReverb.mix;
.5 => sinePan1.pan;
// Synth 2 Parameters
SawOsc sinePad2 => ADSR sineEnv2 => NRev sineReverb2 => Pan2 sinePan2 => dac;
( 150::ms, 10::ms, 1, 500::ms ) => sineEnv2.set;
.15 => sineReverb2.mix;
-.5 => sinePan2.pan;


// Note Duration
.8 => float quarter;
quarter * 2 => float half;
half * 2 => float whole;
quarter / 2 => float eighth;
eighth / 2 => float sixteenth;

48 => int rootNote;
rootNote => int rootNoteNew;


//                     //
// Song Helper Funcion //
//                     //

// Note Frequency
fun int noteFreq( float input )
{
    if( input < 10 )
    {
        return rootNoteNew + 2; // Minor Second Interval
    }
    else if( input < 20 )
    {
        return rootNoteNew + 4; // Major Third Interval
    }
    else if( input < 30 )
    {
        return rootNoteNew + 7; // Fifth Interval
    }
    else if( input < 40 )
    {
        return rootNoteNew + 11; // Major Seventh Interval
    }
    else if( input < 50 )
    {
        return rootNoteNew + 12; // +1 Octave
    }
    else if( input < 60 )
    {
        return rootNoteNew + 14; // Minor Second Interval +1  Octave
    }
    else if( input < 70 )
    {
        return rootNoteNew + 16; // Major Third Interval +1 Octave
    }
    else if( input < 80 )
    {
        return rootNoteNew + 19; // Fifth Interval +1 Octave
    }
    else if( input < 90 )
    {
        return rootNoteNew + 23; // Major Seventh Interval +1 Octave
    }
    else if( input <= 100 )
    {
        return rootNoteNew + 24; // +2 Octaves
    }
}

// Note Duration 
fun float noteDur( float input )
{
    if( input == 0 )
    {
        return whole;
    }
    else if( input < 1 )
    {
        return half;
    }
    else if( input < 2 )
    {
        return quarter;
    }
    else if( input < 3 )
    {
        return eighth;
    }
    else if( input < 4 )
    {
        return sixteenth;
    }
}

// Gain Control based on Data
fun float setGain( float input, float oldMin,
                   float newMin, float oldMax, float newMax)
{
    (newMax - newMin) / (oldMax - oldMin) * (input - oldMax) + newMax => float gainVal;
    return gainVal;
}


// Sequencers //

// Note Sequencer
fun void noteSequencer( float array1[], float array2[], float array3[] )
{
    while ( true ) {
    for( 0 => int i; i < array1.cap(); i++ )
    {
        // Synth 1
        rootNote => rootNoteNew;
        Std.mtof(noteFreq(array1[i])) => sinePad.freq;
        setGain(array1[i], newMinVal, .2, newMaxVal, .45) => sinePad.gain;
        // Synth 2
        rootNote => rootNoteNew;
        Std.mtof(noteFreq(array2[i])) => sinePad2.freq;
        setGain(array2[i], newMinVal, .2, newMaxVal, .45) => sinePad2.gain;
        
        1 => sineEnv.keyOn;
        1 => sineEnv2.keyOn;
        100::ms => now;
        0 => sineEnv.keyOn;
        0 => sineEnv2.keyOn;
        
        // Advance Time based on Growth Rate
        noteDur(array3[i])::second => now;
       
    }
    }
}


//Create OscSend object
OscSend ctrl;
ctrl.setHost("localhost", 7400);

// Kick Sequencer
fun void kickSequencer( float array1[] )
{
    for( 0 => int i; i < array1.cap(); i++ )
    {
        
        if( array1[i] % 2 != 0)
        {
            ctrl.startMsg("/ctrl1/v", "i"); // Send OSC Message
            if( array1[i] < 30 ) // kick 1
            {
                0 => kick1.pos;
                ctrl.addInt(1); // OSC Message = 1
            }
            else if( array1[i] < 50 ) // kick 2
            {
                0 => kick2.pos;
                ctrl.addInt(2); // OSC Message = 2
            }
            else if( array1[i] < 65 ) // kick 3
            {
                0 => kick3.pos;
                ctrl.addInt(3); // OSC Message = 3
            }
            else if( array1[i] < 80 ) // kick 4
            {
                0 => kick4.pos;
                ctrl.addInt(4); // OSC Message = 4
            }
        }
        else{
        }
        // Advance Time
        quarter::second => now;
    }
}

// Snare Sequencer 1
fun void snareSequencerA( float array1[] )
{
    for( 0 => int i; i < array1.cap(); i++ )
    {
        if( array1[i] % 2 != 0)
        {
            ctrl.startMsg("/ctrl2/v", "i"); // Send OSC Message
            if( array1[i] < 30 ) // snare 1
            {
                0 => snareA1.pos;
                ctrl.addInt(1); // OSC Message = 1
            }
            else if( array1[i] < 50 ) // snare 2
            {
                0 => snareA2.pos;
                ctrl.addInt(2); // OSC Message = 2
            }
            else if( array1[i] < 65 ) // snare 3
            {
                0 => snareA3.pos;
                ctrl.addInt(3); // OSC Message = 3
            }
            else if( array1[i] < 80 ) // snare 4
            {
                0 => snareA4.pos;
                ctrl.addInt(4); // OSC Message = 4
            }
        }
        else{
        }
        // Advance Time
        quarter::second => now;
    }
}

// Snare Sequencer 2
fun void snareSequencerB( float array1[] )
{
    for( 0 => int i; i < array1.cap(); i++ )
    {
        if( array1[i] % 2 != 1)
        {
            ctrl.startMsg("/ctrl3/v", "i"); // Send OSC Message
            if( array1[i] < 30 ) // snare 1
            {
                0 => snareB1.pos;
                ctrl.addInt(1); // OSC Message = 1
            }
            else if( array1[i] < 50 ) // snare 2
            {
                0 => snareB2.pos;
                ctrl.addInt(2); // OSC Message = 2
            }
            else if( array1[i] < 65 ) // snare 3
            {
                0 => snareB3.pos;
                ctrl.addInt(3); // OSC Message = 3
            }
            else if( array1[i] < 80 ) // snare 4
            {
                0 => snareB4.pos;
                ctrl.addInt(4); // OSC Message = 4
            }
        }
        else{
        }
        // Advance Time
        quarter::second => now;
    }
}

// HiHat Sequencer
fun void hihatSequencer( float array1[] )
{
    for( 0 => int i; i < array1.cap(); i++ )
    {
        ctrl.startMsg("/ctrl4/v", "i"); // Send OSC Message    
        if( array1[i] < 30 ) // hihat 1
        {
            0 => hh1.pos;
            ctrl.addInt(1); // OSC Message = 1
        }
        else if( array1[i] < 50 ) // hihat 2
        {
            0 => hh2.pos;
            ctrl.addInt(2); // OSC Message = 2
        }
        else if( array1[i] < 65 ) // hihat 3
        {
            0 => hh3.pos;
            ctrl.addInt(3); // OSC Message = 3
        }
        else if( array1[i] < 90 ) // hihat 4
        {
            0 => hh4.pos;
            ctrl.addInt(4); // OSC Message = 4
        }
            
        // Advance Time
        eighth::second => now;
    }
}

// Play Song
while( true ){
    spork ~ noteSequencer(menLife, womenLife, growthRate);
    spork ~ hihatSequencer(womenLife);
    spork ~ kickSequencer(menLife);
    spork ~ snareSequencerA(womenLife);
    spork ~ snareSequencerB(menLife);
    1000::second => now;
}
